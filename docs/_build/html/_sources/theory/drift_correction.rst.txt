Drift Correction
================

The drift correction term :math:`\nabla \cdot \mathbf{D}` compensates for
spatial variation of the dispersion tensor.  Without it, particles
accumulate in low-dispersion regions.

.. math::

   v_{\text{drift},i} = \sum_j \frac{\partial D_{ij}}{\partial x_j}

Par2_Core Modes
---------------

========================  ===============================  ======================
Mode                      Description                      Legacy YAML equivalent
========================  ===============================  ======================
``None``                  No correction (D constant)       —
``Precomputed``           Finite-difference div(D)         ``"finite difference"``
``TrilinearOnFly``        Analytical trilinear derivatives  ``"trilinear"``
========================  ===============================  ======================

TrilinearOnFly Derivatives
~~~~~~~~~~~~~~~~~~~~~~~~~

Computes :math:`\nabla \cdot \mathbf{D}` at the **particle position**
using trilinear derivative interpolation of D-tensor evaluated at the
8 cell corners.  For example:

.. math::

   \frac{\partial D_{xx}}{\partial x}\bigg|_{\mathbf{p}}
     = \text{trilinearDevX}\!\left(t_x, t_y, t_z,\; D_{xx}^{\text{corners}}\right)

where ``trilinearDevX`` computes :math:`(v_1 - v_0)/\Delta x` on the
differentiation axis and interpolates in the remaining two dimensions.

**Zero-velocity tolerance** is applied at each corner before evaluating D:
``toll = 0.01 * Dm / αL``; if all velocity components are below toll,
:math:`v_x` is set to toll.

**Computational cost:**  24 velocity loads (8 corners × 3 components),
48 D-tensor evaluations, 9 trilinear derivative calls.

Precomputed Finite-Difference Stencil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Two-step approach (separate kernels):

1. **Step 1:** Compute full D tensor at each cell centre from face-velocity
   interpolation at the cell centre.

2. **Step 2:** Finite differences:

   .. math::

      \frac{\partial D_{ij}}{\partial x}\bigg|_k =
      \begin{cases}
        (D_{ij}[k+1] - D_{ij}[k]) / \Delta x
          & k = 0 \text{ (forward)} \\
        (D_{ij}[k+1] - D_{ij}[k-1]) / (2\Delta x)
          & 0 < k < n_x{-}1 \text{ (central)} \\
        (D_{ij}[k] - D_{ij}[k-1]) / \Delta x
          & k = n_x{-}1 \text{ (backward)}
      \end{cases}

   Requires 9 temporary arrays (6 D-tensor + 3 drift) of ``num_cells``
   elements each.

In the move kernel, precomputed drift is a **piecewise-constant** cell
lookup (no within-cell interpolation).
